#################################
# BASIC INSTALLATION            #
#################################

- name: Install PostgreSQL
  apt:
    name: postgresql
    state: present

- name: Find PostgreSQL version directory
  command: "ls /etc/postgresql/"
  register: postgresql_version_dir
  changed_when: false

#################################
# MOUNT LARGEST PARTITION       #
#################################

- name: Find the largest available drive
  command: lsblk -b -o NAME,TYPE,SIZE,FSAVAIL,FSTYPE,MOUNTPOINT --json
  register: lsblk_output
  changed_when: false

- name: Parse available partitions
  set_fact:
    largest_partition: "{{ (lsblk_output.stdout | from_json).blockdevices 
                          | selectattr('children', 'defined')
                          | map(attribute='children') 
                          | flatten 
                          | selectattr('fsavail', 'defined') 
                          | selectattr('fsavail', 'ne', 'null') 
                          | sort(attribute='fsavail', reverse=True) 
                          | first | default({}, true) }}"

- name: Ensure mount directory exists
  file:
    path: /mnt/postgres_data
    state: directory
    mode: '0755'

- name: Create a symlink for the device as /dev/database
  file:
    src: "/dev/{{ largest_partition.name }}"
    dest: /dev/database
    state: link
    force: yes

- name: Format the drive (if not already formatted)
  command: "mkfs.ext4 -F /dev/{{ largest_partition.name }}"
  when: largest_partition.fstype == ""

- name: Mount the device at /mnt/postgres_data
  mount:
    path: /mnt/postgres_data
    src: "/dev/{{ largest_partition.name }}"
    fstype: ext4
    state: mounted

- name: Persist mount in /etc/fstab
  lineinfile:
    path: /etc/fstab
    line: "/dev/database  /mnt/postgres_data  ext4  defaults,noatime  0 1"
    state: present

#################################
# MOVE DATA TO NEW LOCATION     #
#################################

- name: Move existing PostgreSQL data directory to the new location
  command: "mv /var/lib/postgresql /mnt/postgres_data/"
  args:
    creates: "/mnt/postgres_data/postgresql"

- name: Update PostgreSQL data directory permissions
  file:
    path: /mnt/postgres_data/postgresql
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'
    recurse: yes

- name: Update PostgreSQL configuration to use new data directory
  lineinfile:
    path: "/etc/postgresql/{{ postgresql_version_dir.stdout }}/main/postgresql.conf"
    regexp: '^data_directory ='
    line: "data_directory = '/mnt/postgres_data/postgresql/{{ postgresql_version_dir.stdout }}/main'"
    state: present

#################################
# ALLOWED CONNECTIONS           #
#################################

- name: Configure PostgreSQL to listen on localhost and private network
  lineinfile:
    path: "/etc/postgresql/{{ postgresql_version_dir.stdout }}/main/postgresql.conf"
    regexp: '^#?listen_addresses'
    line: "listen_addresses = 'localhost,{{ hostvars['postgres']['ansible_default_ipv4']['address'] }}'"

- name: Allow local socket connections for postgres user (peer auth)
  lineinfile:
    path: /etc/postgresql/{{ postgresql_version_dir.stdout }}/main/pg_hba.conf
    line: "local   all             postgres                                peer"
    insertafter: "^# TYPE"
    state: present

- name: Allow local socket connections for other users (password auth)
  lineinfile:
    path: /etc/postgresql/{{ postgresql_version_dir.stdout }}/main/pg_hba.conf
    line: "local   all             all                                     scram-sha-256"
    insertafter: "^local.*postgres.*peer"
    state: present

- name: Allow localhost connections in pg_hba.conf
  lineinfile:
    path: /etc/postgresql/{{ postgresql_version_dir.stdout }}/main/pg_hba.conf
    line: "host    all             all             127.0.0.1/32        scram-sha-256"
    state: present

- name: Allow cluster node connections in pg_hba.conf
  lineinfile:
    path: /etc/postgresql/{{ postgresql_version_dir.stdout }}/main/pg_hba.conf
    line: "host    all             all             {{ hostvars[item]['ansible_default_ipv4']['address'] }}/32        scram-sha-256"
    state: present
  loop:
    - master
    - worker1
    - worker2
    - worker3
    - postgres

#################################
# SYSTEMD SERVICE               #
#################################

- name: Restart PostgreSQL service to apply configuration changes
  systemd:
    name: "postgresql@{{ postgresql_version_dir.stdout }}-main"
    enabled: yes
    state: restarted

- name: Confirm PostgreSQL service is running
  systemd:
    name: "postgresql@{{ postgresql_version_dir.stdout }}-main"
    state: started

#################################
# DATABASE SETUP                #
#################################

- name: Copy SQL files to remote host
  synchronize:
    src: "{{ playbook_dir }}/../../postgres/"
    dest: /tmp/postgres_setup/
    mode: push

- name: Create database (surf_analytics)
  become_user: postgres
  shell: |
    psql -tc "SELECT 1 FROM pg_database WHERE datname = 'surf_analytics'" | grep -q 1 || psql -c "CREATE DATABASE surf_analytics"
  args:
    executable: /bin/bash
  changed_when: false

- name: Create schemas
  become_user: postgres
  shell: |
    psql -d surf_analytics -f /tmp/postgres_setup/databases/surf_analytics/schemas/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - reference.sql
    - ingested.sql
  changed_when: false

- name: Create users (with templated passwords)
  become_user: postgres
  shell: |
    psql -d surf_analytics -c "
    DO \$\$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '{{ item.name }}') THEN
            CREATE USER {{ item.name }} WITH {{ item.options }} PASSWORD '{{ item.password }}';
        END IF;
    END
    \$\$;"
  args:
    executable: /bin/bash
  loop:
    - { name: 'platform_admin', options: 'LOGIN SUPERUSER', password: '{{ platform_admin_password }}' }
    - { name: 'argo_runner', options: 'LOGIN', password: '{{ argo_runner_password }}' }
  no_log: true
  changed_when: false

- name: Create roles
  become_user: postgres
  shell: |
    psql -d surf_analytics -f /tmp/postgres_setup/roles/service_accounts/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - argo_read.sql
    - argo_write.sql
  changed_when: false

- name: Grant roles to argo_runner
  become_user: postgres
  shell: |
    psql -d surf_analytics -c "GRANT argo_read TO argo_runner; GRANT argo_write TO argo_runner;"
  args:
    executable: /bin/bash
  changed_when: false

- name: Create reference tables (order matters - buoy_info and spot_info first)
  become_user: postgres
  shell: |
    psql -d surf_analytics -f /tmp/postgres_setup/databases/surf_analytics/tables/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - reference.buoy_info.sql
    - reference.spot_info.sql
    - reference.spot_buoy_link.sql
  changed_when: false

- name: Create ingested tables
  become_user: postgres
  shell: |
    psql -d surf_analytics -f /tmp/postgres_setup/databases/surf_analytics/tables/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - ingested.swell_data.sql
    - ingested.wind_data.sql
  changed_when: false

#################################
# SALT APP DATABASE SETUP       #
#################################

- name: Create database (salt_app)
  become_user: postgres
  shell: |
    psql -tc "SELECT 1 FROM pg_database WHERE datname = 'salt_app'" | grep -q 1 || psql -c "CREATE DATABASE salt_app"
  args:
    executable: /bin/bash
  changed_when: false

- name: Create schemas for salt_app
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/databases/salt_app/schemas/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - public.sql
    - auth.sql
  changed_when: false

- name: Create custom types for salt_app
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/databases/salt_app/types/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - app_role.sql
  changed_when: false

- name: Create salt_app users (with templated passwords)
  become_user: postgres
  shell: |
    psql -d salt_app -c "
    DO \$\$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '{{ item.name }}') THEN
            CREATE USER {{ item.name }} WITH {{ item.options }} PASSWORD '{{ item.password }}';
        END IF;
    END
    \$\$;"
  args:
    executable: /bin/bash
  loop:
    - { name: 'salt_admin', options: 'LOGIN', password: '{{ salt_admin_password }}' }
    - { name: 'salt_app', options: 'LOGIN', password: '{{ salt_app_password }}' }
  no_log: true
  changed_when: false

- name: Create salt_app roles
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/roles/service_accounts/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - salt_read.sql
    - salt_write.sql
  changed_when: false

- name: Grant roles to salt_app users
  become_user: postgres
  shell: |
    psql -d salt_app -c "GRANT salt_read TO salt_app; GRANT salt_write TO salt_app;"
    psql -d salt_app -c "GRANT ALL PRIVILEGES ON DATABASE salt_app TO salt_admin;"
  args:
    executable: /bin/bash
  changed_when: false

- name: Create salt_app tables (auth schema first)
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/databases/salt_app/tables/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - auth.users.sql
  changed_when: false

- name: Create salt_app tables (public schema)
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/databases/salt_app/tables/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - public.profiles.sql
    - public.user_roles.sql
    - public.spots.sql
    - public.boards.sql
    - public.sessions.sql
    - public.session_media.sql
    - public.session_swell_data.sql
    - public.session_likes.sql
    - public.session_kooks.sql
    - public.session_comments.sql
    - public.follows.sql
    - public.favorite_spots.sql
    - public.saved_locations.sql
    - public.forecast_comments.sql
    - public.forecast_comment_likes.sql
    - public.forecast_comment_kooks.sql
  changed_when: false

- name: Create salt_app functions
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/databases/salt_app/functions/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - update_updated_at_column.sql
    - handle_new_user.sql
    - has_role.sql
  changed_when: false

- name: Create salt_app triggers
  become_user: postgres
  shell: |
    psql -d salt_app -f /tmp/postgres_setup/databases/salt_app/triggers/{{ item }}
  args:
    executable: /bin/bash
  loop:
    - users_updated_at.sql
    - profiles_updated_at.sql
    - boards_updated_at.sql
    - sessions_updated_at.sql
    - new_user_profile.sql
  changed_when: false

- name: Clean up temporary SQL files
  file:
    path: /tmp/postgres_setup
    state: absent
